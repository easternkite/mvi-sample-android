package com.example.sample_mvi.core.common.mvi

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.flatMapConcat
import kotlinx.coroutines.flow.onEach
import kotlinx.coroutines.flow.receiveAsFlow
import kotlinx.coroutines.flow.runningFold
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch

/**
 * An abstract ViewModel designed to implement the Model-View-Intent (MVI) architectural pattern.
 *
 * This ViewModel manages a unidirectional data flow where:
 *  1. **Actions** (user intents) are sent to the ViewModel.
 *  2. **Effects** (side effects resulting from actions) are generated by the ViewModel.
 *  3. **State** is updated based on the effects, representing the current UI state.
 *  4. **Effects** are propagated to the View for one-time events like navigation, showing a snackbar, etc.
 *  5. **State** updates are observed by the View to re-render the UI.
 *
 * @param ACTION The type of user actions that can be sent to the ViewModel.
 * @param STATE The type of the UI state managed by the ViewModel.
 * @param EFFECT The type of side effects that the ViewModel can produce.
 * @property effect A [Flow] of [EFFECT]s that the View can observe to handle one-time events.
 * @property state A [Flow] of [STATE]s that the View can observe to re-render the UI.
 * @property initialState The initial [STATE] of the ViewModel.
 */
@OptIn(ExperimentalCoroutinesApi::class)
abstract class MviViewModel<ACTION : UiAction, STATE : UiState, EFFECT : SideEffect>(
    initialState: STATE
): ViewModel() {
    private val actionChannel = Channel<ACTION>(Channel.Factory.BUFFERED)
    private val effectChannel = Channel<EFFECT>(Channel.Factory.BUFFERED)

    val effect = effectChannel
        .receiveAsFlow()

    val state = actionChannel
        .receiveAsFlow()
        .flatMapConcat(::onAction)
        .onEach(effectChannel::send)
        .runningFold(initialState, ::reduce)
        .stateIn(viewModelScope, SharingStarted.Companion.Eagerly, initialState)

    fun send(action: ACTION) {
        viewModelScope.launch {
            actionChannel.send(action)
        }
    }

    abstract fun onAction(action: ACTION): Flow<EFFECT>
    abstract fun reduce(prevState: STATE, currentEvent: EFFECT): STATE
}